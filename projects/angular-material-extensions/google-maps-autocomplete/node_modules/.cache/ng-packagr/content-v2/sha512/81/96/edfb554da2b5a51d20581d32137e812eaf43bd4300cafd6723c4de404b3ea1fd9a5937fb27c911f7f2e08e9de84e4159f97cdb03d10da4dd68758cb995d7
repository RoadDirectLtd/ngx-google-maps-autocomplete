{"hash":"a0e15b22ce591332a2125342b696cdcb8f81cd18","fesm2022":[{"exports":["ApiKeyToken","Appearance","MatGoogleMapsAutocompleteComponent","MatGoogleMapsAutocompleteDirective","MatGoogleMapsAutocompleteModule","MatSearchGoogleMapsAutocompleteComponent","MatValidateAddressDirective","parseGermanAddress"],"facadeModuleId":"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/angular-material-extensions-google-maps-autocomplete.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/helpers/parser.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/germand.address.interface.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/location.interface.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/index.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/tokens/index.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/directives/address-validator/mat-address-validator.directive.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/mat-google-maps-autocomplete.component.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/animations/index.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/services/script-loader.service.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/directives/mat-google-maps-autocomplete.directive.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/index.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/mat-google-maps-autocomplete.module.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/public-api.mjs","/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/angular-material-extensions-google-maps-autocomplete.mjs"],"name":"angular-material-extensions-google-maps-autocomplete","type":"chunk","dynamicImports":[],"fileName":"angular-material-extensions-google-maps-autocomplete.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["InjectionToken","*","forwardRef","Directive","EventEmitter","Component","ViewChild","Input","Output","Injectable","PLATFORM_ID","Inject","HostListener","NgModule"],"@angular/forms":["NG_VALIDATORS","UntypedFormControl","Validators","NG_VALUE_ACCESSOR","*","FormsModule","ReactiveFormsModule"],"@agm/core":["*"],"@angular/common":["*","isPlatformBrowser","CommonModule"],"@angular/material/input":["*","MatInputModule"],"@angular/material/form-field":["*"],"@angular/animations":["animation","style","animate","trigger","transition","useAnimation","state","query","stagger","animateChild"],"rxjs/operators":["distinctUntilChanged","debounceTime","takeUntil"],"rxjs":["Subject"],"@angular/flex-layout/flex":["*"],"@angular/material/icon":["*","MatIconModule"],"@angular/flex-layout":["FlexLayoutModule"]},"imports":["@angular/core","@angular/forms","@agm/core","@angular/common","@angular/material/input","@angular/material/form-field","@angular/animations","rxjs/operators","rxjs","@angular/flex-layout/flex","@angular/material/icon","@angular/flex-layout"],"modules":{"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/helpers/parser.mjs":{"code":"function parseGermanAddress(placeResult) {\n    const germanAddress = {\n        gmID: placeResult.id,\n        icon: placeResult.icon,\n        url: placeResult.url,\n        placeID: placeResult.place_id,\n        displayAddress: placeResult.formatted_address,\n        name: placeResult.name,\n        vicinity: placeResult.vicinity,\n        locality: {},\n        state: {},\n        country: {},\n        geoLocation: { latitude: -1, longitude: -1 },\n    };\n    if (placeResult.geometry && placeResult.geometry.location) {\n        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n    }\n    if (placeResult.address_components && placeResult.address_components.length > 0) {\n        placeResult.address_components.forEach(value => {\n            if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n            }\n            if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n            }\n            if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n            }\n            if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n            }\n            if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n            }\n            if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n            }\n        });\n    }\n    return germanAddress;\n}","originalLength":8079,"removedExports":[],"renderedExports":["parseGermanAddress"],"renderedLength":2177},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/germand.address.interface.mjs":{"code":"","originalLength":1241,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/location.interface.mjs":{"code":"","originalLength":485,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/interfaces/index.mjs":{"code":"","originalLength":593,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/tokens/index.mjs":{"code":"const ApiKeyToken = new InjectionToken('apiKey');","originalLength":727,"removedExports":[],"renderedExports":["ApiKeyToken"],"renderedLength":49},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/directives/address-validator/mat-address-validator.directive.mjs":{"code":"// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\nclass MatValidateAddressDirective {\n    subscription;\n    _address;\n    constructor() {\n    }\n    validate() {\n        return (control) => {\n            return this.address ? null : {\n                validateAddress: {\n                    valid: false\n                }\n            };\n        };\n    }\n    subscribe(eventEmitter) {\n        this.subscription = eventEmitter.subscribe((address) => {\n            this.address = address;\n        });\n    }\n    unsubscribe() {\n        this.subscription.unsubscribe();\n    }\n    get address() {\n        return this._address;\n    }\n    set address(value) {\n        this._address = value;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatValidateAddressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\", providers: [\n            { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n        ], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatValidateAddressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n                    providers: [\n                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });","originalLength":5634,"removedExports":[],"renderedExports":["MatValidateAddressDirective"],"renderedLength":1884},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/mat-google-maps-autocomplete.component.mjs":{"code":"var Appearance;\n(function (Appearance) {\n    Appearance[\"STANDARD\"] = \"standard\";\n    Appearance[\"FILL\"] = \"fill\";\n    Appearance[\"OUTLINE\"] = \"outline\";\n    Appearance[\"LEGACY\"] = \"legacy\";\n})(Appearance || (Appearance = {}));\nclass MatGoogleMapsAutocompleteComponent {\n    mapsAPILoader;\n    ngZone;\n    searchElementRef;\n    addressLabelText = 'Address';\n    placeholderText = 'Please enter the address';\n    requiredErrorText = 'The address is required';\n    invalidErrorText = 'The address is not valid';\n    appearance = Appearance.STANDARD;\n    value;\n    address;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    // types: string[] = ['address'];\n    type;\n    autoCompleteOptions = {};\n    onChange = new EventEmitter();\n    onAutocompleteSelected = new EventEmitter();\n    onGermanAddressMapped = new EventEmitter();\n    onLocationSelected = new EventEmitter();\n    onNewPlaceResult = new EventEmitter();\n    addressValidator = new MatValidateAddressDirective();\n    addressSearchControl = new UntypedFormControl({ value: null }, Validators.compose([\n        Validators.required,\n        this.addressValidator.validate()\n    ]));\n    propagateChange = (_) => {\n    };\n    constructor(mapsAPILoader, ngZone) {\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n    }\n    ngOnInit() {\n        this.addressValidator.subscribe(this.onNewPlaceResult);\n        const options = {\n            // types: ['address'],\n            // componentRestrictions: {country: this.country},\n            placeIdOnly: this.placeIdOnly,\n            strictBounds: this.strictBounds,\n            // types: this.types,\n            type: this.type\n        };\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.componentRestrictions = { country: this.country } : null;\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.types = this.types : null;\n        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n        this.initGoogleMapsAutocomplete();\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    if (place.address_components) {\n                        place.address_components.forEach(value => {\n                            if (value.types.indexOf('street_number') > -1) {\n                                germanAddress.streetNumber = value.short_name;\n                            }\n                            if (value.types.indexOf('route') > -1) {\n                                germanAddress.streetName = value.long_name;\n                            }\n                            if (value.types.indexOf('postal_code') > -1) {\n                                germanAddress.postalCode = Number(value.short_name);\n                            }\n                            if (value.types.indexOf('sublocality') > -1) {\n                                germanAddress.sublocality = value.long_name;\n                            }\n                            if (value.types.indexOf('locality') > -1) {\n                                germanAddress.locality.long = value.long_name;\n                                germanAddress.locality.short = value.short_name;\n                            }\n                            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                                germanAddress.state.long = value.long_name;\n                                germanAddress.state.short = value.short_name;\n                            }\n                            if (value.types.indexOf('country') > -1) {\n                                germanAddress.country.long = value.long_name;\n                                germanAddress.country.short = value.short_name;\n                            }\n                            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                                germanAddress.locality.short = value.short_name;\n                            }\n                        });\n                    }\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                        this.value = place;\n                        this.propagateChange(this.value);\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    onQuery(event) {\n        this.onChange.emit(this.address);\n    }\n    resetAddress() {\n        this.address = null;\n        this.addressSearchControl.updateValueAndValidity();\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n        throw new Error('Method not implemented.');\n    }\n    setDisabledState(isDisabled) {\n        throw new Error('Method not implemented.');\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i1.MapsAPILoader }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatGoogleMapsAutocompleteComponent, selector: \"mat-google-maps-autocomplete\", inputs: { addressLabelText: \"addressLabelText\", placeholderText: \"placeholderText\", requiredErrorText: \"requiredErrorText\", invalidErrorText: \"invalidErrorText\", appearance: \"appearance\", value: \"value\", address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                multi: true\n            }\n        ], viewQueries: [{ propertyName: \"searchElementRef\", first: true, predicate: [\"search\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0, template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { kind: \"directive\", type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { kind: \"directive\", type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { kind: \"directive\", type: i1$1.NgModel, selector: \"[ngModel]:not([formControlName]):not([formControl])\", inputs: [\"name\", \"disabled\", \"ngModel\", \"ngModelOptions\"], outputs: [\"ngModelChange\"], exportAs: [\"ngModel\"] }, { kind: \"directive\", type: i4.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { kind: \"component\", type: i5.MatFormField, selector: \"mat-form-field\", inputs: [\"hideRequiredMarker\", \"color\", \"floatLabel\", \"appearance\", \"subscriptSizing\", \"hintLabel\"], exportAs: [\"matFormField\"] }, { kind: \"directive\", type: i5.MatLabel, selector: \"mat-label\" }, { kind: \"directive\", type: i5.MatError, selector: \"mat-error, [matError]\", inputs: [\"id\"] }, { kind: \"directive\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\" }] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: i1.MapsAPILoader }, { type: i0.NgZone }]; }, propDecorators: { searchElementRef: [{\n                type: ViewChild,\n                args: ['search']\n            }], addressLabelText: [{\n                type: Input\n            }], placeholderText: [{\n                type: Input\n            }], requiredErrorText: [{\n                type: Input\n            }], invalidErrorText: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }] } });","originalLength":33660,"removedExports":[],"renderedExports":["Appearance","MatGoogleMapsAutocompleteComponent"],"renderedLength":13037},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/animations/index.mjs":{"code":"const customAnimation = animation([\n    style({\n        opacity: '{{opacity}}',\n        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n], {\n    params: {\n        duration: '200ms',\n        delay: '0ms',\n        opacity: '0',\n        scale: '1',\n        x: '0',\n        y: '0',\n        z: '0'\n    }\n});\nconst InputAnimations = [\n    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n    trigger('animateStagger', [\n        state('50', style('*')),\n        state('100', style('*')),\n        state('200', style('*')),\n        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),\n        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),\n        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))\n    ]),\n];","originalLength":4574,"removedExports":[],"renderedExports":["InputAnimations"],"renderedLength":975},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/services/script-loader.service.mjs":{"code":"class ScriptLoaderService {\n    loadedScripts = {};\n    scriptPromises = {}; // Neu\n    loadScript(src) {\n        // Wenn das Skript bereits erfolgreich geladen wurde, sofort auflösen\n        if (this.loadedScripts[src]) {\n            return Promise.resolve();\n        }\n        // Wenn ein Ladevorgang für dieses Skript bereits im Gange ist, das vorhandene Promise zurückgeben\n        if (this.scriptPromises[src]) {\n            return this.scriptPromises[src];\n        }\n        // Ein neues Promise für das Skript-Laden erstellen und speichern\n        this.scriptPromises[src] = new Promise((resolve, reject) => {\n            const script = document.createElement('script');\n            script.src = src;\n            script.async = true; // Empfohlen für externe Skripte\n            script.onload = () => {\n                this.loadedScripts[src] = true; // Markiere das Skript als geladen\n                resolve();\n            };\n            script.onerror = (error) => {\n                this.scriptPromises[src] = null; // Bei Fehler, entferne das Promise, damit erneute Versuche möglich sind\n                reject(error);\n            };\n            document.body.appendChild(script);\n        });\n        return this.scriptPromises[src];\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });","originalLength":5597,"removedExports":[],"renderedExports":["ScriptLoaderService"],"renderedLength":1830},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/directives/mat-google-maps-autocomplete.directive.mjs":{"code":"class MatGoogleMapsAutocompleteDirective {\n    platformId;\n    apiKey;\n    elemRef;\n    cf;\n    loaderService;\n    ngZone;\n    inputField;\n    autocomplete;\n    address;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    type;\n    autoCompleteOptions = {};\n    onChange = new EventEmitter();\n    onAutocompleteSelected = new EventEmitter();\n    onGermanAddressMapped = new EventEmitter();\n    onLocationSelected = new EventEmitter();\n    disabled;\n    _value;\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        this.cf.markForCheck();\n    }\n    onNewPlaceResult = new EventEmitter();\n    propagateChange = (_) => {\n    };\n    constructor(platformId, apiKey, elemRef, cf, loaderService, ngZone) {\n        this.platformId = platformId;\n        this.apiKey = apiKey;\n        this.elemRef = elemRef;\n        this.cf = cf;\n        this.loaderService = loaderService;\n        this.ngZone = ngZone;\n    }\n    ngOnDestroy() {\n        throw new Error('Method not implemented.');\n    }\n    ngAfterViewInit() {\n        this.loadMap();\n    }\n    ngOnInit() {\n        console.log(\"this.apiKey = \", this.apiKey);\n    }\n    validate(fc) {\n        return fc.hasValidator(Validators.required) ? !!fc?.value : true;\n    }\n    onChangeInputValue() {\n        const value = this.elemRef.nativeElement?.value;\n        this.value = value;\n    }\n    initGoogleMapsAutocomplete() {\n        const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n            this.ngZone.run(() => {\n                // get the place result\n                const place = autocomplete.getPlace();\n                const germanAddress = {\n                    gmID: place.id,\n                    icon: place.icon,\n                    url: place.url,\n                    placeID: place.place_id,\n                    displayAddress: place.formatted_address,\n                    name: place.name,\n                    vicinity: place.vicinity,\n                    locality: {},\n                    state: {},\n                    country: {},\n                    geoLocation: { latitude: -1, longitude: -1 },\n                };\n                if (place.geometry && place.geometry.location) {\n                    germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                    germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                }\n                place.address_components.forEach(value => {\n                    if (value.types.indexOf('street_number') > -1) {\n                        germanAddress.streetNumber = value.short_name;\n                    }\n                    if (value.types.indexOf('route') > -1) {\n                        germanAddress.streetName = value.long_name;\n                    }\n                    if (value.types.indexOf('postal_code') > -1) {\n                        germanAddress.postalCode = Number(value.short_name);\n                    }\n                    if (value.types.indexOf('sublocality') > -1) {\n                        germanAddress.sublocality = value.long_name;\n                    }\n                    if (value.types.indexOf('locality') > -1) {\n                        germanAddress.locality.long = value.long_name;\n                        germanAddress.locality.short = value.short_name;\n                    }\n                    if (value.types.indexOf('administrative_area_level_1') > -1) {\n                        germanAddress.state.long = value.long_name;\n                        germanAddress.state.short = value.short_name;\n                    }\n                    if (value.types.indexOf('country') > -1) {\n                        germanAddress.country.long = value.long_name;\n                        germanAddress.country.short = value.short_name;\n                    }\n                    if (value.types.indexOf('administrative_area_level_3') > -1) {\n                        germanAddress.locality.short = value.short_name;\n                    }\n                });\n                this.onGermanAddressMapped.emit(germanAddress);\n                this.value = place.formatted_address;\n                this.address = place.formatted_address;\n                this.onAutocompleteSelected.emit(place);\n                this.onLocationSelected.emit({\n                    latitude: place.geometry.location.lat(),\n                    longitude: place.geometry.location.lng()\n                });\n            });\n        });\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    loadMap() {\n        this.loaderService.loadScript(`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=places`)\n            .then(() => {\n            this.initMap();\n        })\n            .catch(error => console.error('Google Maps loading failed: ', error));\n    }\n    initMap() {\n        if (isPlatformBrowser(this.platformId)) {\n            console.log(\"on after view init --> \", this.elemRef.nativeElement);\n            this.autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement);\n            const options = {\n                // types: ['address'],\n                // componentRestrictions: {country: this.country},\n                placeIdOnly: this.placeIdOnly,\n                strictBounds: this.strictBounds,\n                // types: this.types,\n                type: this.type\n            };\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.componentRestrictions = { country: this.country } : null;\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.types = this.types : null;\n            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n            this.initGoogleMapsAutocomplete();\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, deps: [{ token: PLATFORM_ID }, { token: ApiKeyToken }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: ScriptLoaderService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: { address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\", value: \"value\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, host: { listeners: { \"change\": \"onChangeInputValue()\" } }, providers: [\n            {\n                provide: NG_VALIDATORS,\n                useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                multi: true\n            }\n        ], viewQueries: [{ propertyName: \"inputField\", first: true, predicate: [\"inputField\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matGoogleMapsAutocomplete]',\n                    exportAs: 'matGoogleMapsAutocomplete',\n                    providers: [\n                        {\n                            provide: NG_VALIDATORS,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                            multi: true\n                        }\n                    ]\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [ApiKeyToken]\n                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: ScriptLoaderService }, { type: i0.NgZone }]; }, propDecorators: { inputField: [{\n                type: ViewChild,\n                args: ['inputField']\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }], onChangeInputValue: [{\n                type: HostListener,\n                args: ['change']\n            }] } });","originalLength":28631,"removedExports":[],"renderedExports":["MatGoogleMapsAutocompleteDirective"],"renderedLength":9485},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.mjs":{"code":"class MatSearchGoogleMapsAutocompleteComponent {\n    formBuilder;\n    constructor(formBuilder) {\n        this.formBuilder = formBuilder;\n        // Set the private defaults\n        this._unsubscribeAll = new Subject();\n    }\n    searchBarAppearance;\n    appearance = Appearance.STANDARD;\n    searchAddressLabel = 'Search Address';\n    streetNameLabel = 'Street';\n    streetNumberLabel = 'Nr.';\n    postalCodeLabel = 'PLZ';\n    localityLabel = 'Locality';\n    vicinityLabel = 'Vicinity';\n    showVicinity;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    // types: string[] = ['address'];\n    type;\n    readonly;\n    disableSearch;\n    _value;\n    onGermanAddressMapped = new EventEmitter();\n    germanAddress;\n    addressFormGroup;\n    firstInit = true;\n    // Private\n    _unsubscribeAll;\n    propagateChange = (_) => {\n    };\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n    }\n    ngOnInit() {\n        this.createAddressFormGroup();\n        this.enableCustomInput();\n    }\n    createAddressFormGroup() {\n        this.addressFormGroup = this.formBuilder.group({\n            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n            locality: this.formBuilder.group({\n                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n            }),\n        });\n    }\n    enableCustomInput() {\n        this.addressFormGroup\n            .get('streetName')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetName => {\n            !this.value ? this.value = { streetName } : this.value.streetName = streetName;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('streetNumber')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetNumber => {\n            !this.value ? this.value = { streetNumber } : this.value.streetNumber = streetNumber;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('postalCode')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(postalCode => {\n            !this.value ? this.value = { postalCode } : this.value.postalCode = postalCode;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('vicinity')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(vicinity => {\n            !this.value ? this.value = { vicinity } : this.value.vicinity = vicinity;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('locality')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(locality => {\n            !this.value ? this.value = { locality } : this.value.locality = locality;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n    }\n    parseDisplayAddress() {\n        return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`;\n    }\n    syncAutoComplete($event) {\n        if (this.germanAddress) {\n            this.addressFormGroup.reset();\n        }\n        const germanAddress = parseGermanAddress($event);\n        this.germanAddress = germanAddress;\n        if (germanAddress.vicinity) {\n            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetName) {\n            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetNumber) {\n            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.postalCode) {\n            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.locality && germanAddress.locality.long) {\n            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, { emitEvent: false, onlySelf: true });\n        }\n        this.value = germanAddress;\n        this.onGermanAddressMapped.emit(germanAddress);\n    }\n    writeValue(obj) {\n        let shouldRecreateFG = false;\n        if (obj) {\n            if (!this.value && this.firstInit) {\n                shouldRecreateFG = true;\n            }\n            this.value = obj;\n            if (shouldRecreateFG) {\n                this.createAddressFormGroup();\n                this.firstInit = false;\n            }\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, deps: [{ token: i1$1.UntypedFormBuilder }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatSearchGoogleMapsAutocompleteComponent, selector: \"mat-search-google-maps-autocomplete\", inputs: { searchBarAppearance: \"searchBarAppearance\", appearance: \"appearance\", searchAddressLabel: \"searchAddressLabel\", streetNameLabel: \"streetNameLabel\", streetNumberLabel: \"streetNumberLabel\", postalCodeLabel: \"postalCodeLabel\", localityLabel: \"localityLabel\", vicinityLabel: \"vicinityLabel\", showVicinity: \"showVicinity\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", readonly: \"readonly\", disableSearch: \"disableSearch\", _value: \"_value\", value: \"value\" }, outputs: { onGermanAddressMapped: \"onGermanAddressMapped\" }, providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                multi: true\n            }\n        ], ngImport: i0, template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"], dependencies: [{ kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i1$1.ɵNgNoValidate, selector: \"form:not([ngNoForm]):not([ngNativeValidate])\" }, { kind: \"directive\", type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { kind: \"directive\", type: i1$1.NumberValueAccessor, selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\" }, { kind: \"directive\", type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { kind: \"directive\", type: i1$1.NgControlStatusGroup, selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\" }, { kind: \"directive\", type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { kind: \"directive\", type: i1$1.FormGroupDirective, selector: \"[formGroup]\", inputs: [\"formGroup\"], outputs: [\"ngSubmit\"], exportAs: [\"ngForm\"] }, { kind: \"directive\", type: i1$1.FormControlName, selector: \"[formControlName]\", inputs: [\"formControlName\", \"disabled\", \"ngModel\"], outputs: [\"ngModelChange\"] }, { kind: \"directive\", type: i1$1.FormGroupName, selector: \"[formGroupName]\", inputs: [\"formGroupName\"] }, { kind: \"directive\", type: i3.DefaultLayoutDirective, selector: \"  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],  [fxLayout.gt-md], [fxLayout.gt-lg]\", inputs: [\"fxLayout\", \"fxLayout.xs\", \"fxLayout.sm\", \"fxLayout.md\", \"fxLayout.lg\", \"fxLayout.xl\", \"fxLayout.lt-sm\", \"fxLayout.lt-md\", \"fxLayout.lt-lg\", \"fxLayout.lt-xl\", \"fxLayout.gt-xs\", \"fxLayout.gt-sm\", \"fxLayout.gt-md\", \"fxLayout.gt-lg\"] }, { kind: \"directive\", type: i3.DefaultLayoutGapDirective, selector: \"  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\", inputs: [\"fxLayoutGap\", \"fxLayoutGap.xs\", \"fxLayoutGap.sm\", \"fxLayoutGap.md\", \"fxLayoutGap.lg\", \"fxLayoutGap.xl\", \"fxLayoutGap.lt-sm\", \"fxLayoutGap.lt-md\", \"fxLayoutGap.lt-lg\", \"fxLayoutGap.lt-xl\", \"fxLayoutGap.gt-xs\", \"fxLayoutGap.gt-sm\", \"fxLayoutGap.gt-md\", \"fxLayoutGap.gt-lg\"] }, { kind: \"directive\", type: i3.DefaultFlexDirective, selector: \"  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],  [fxFlex.gt-md], [fxFlex.gt-lg]\", inputs: [\"fxFlex\", \"fxFlex.xs\", \"fxFlex.sm\", \"fxFlex.md\", \"fxFlex.lg\", \"fxFlex.xl\", \"fxFlex.lt-sm\", \"fxFlex.lt-md\", \"fxFlex.lt-lg\", \"fxFlex.lt-xl\", \"fxFlex.gt-xs\", \"fxFlex.gt-sm\", \"fxFlex.gt-md\", \"fxFlex.gt-lg\"] }, { kind: \"directive\", type: i4.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { kind: \"component\", type: i5.MatFormField, selector: \"mat-form-field\", inputs: [\"hideRequiredMarker\", \"color\", \"floatLabel\", \"appearance\", \"subscriptSizing\", \"hintLabel\"], exportAs: [\"matFormField\"] }, { kind: \"directive\", type: i5.MatLabel, selector: \"mat-label\" }, { kind: \"directive\", type: i5.MatSuffix, selector: \"[matSuffix], [matIconSuffix], [matTextSuffix]\", inputs: [\"matTextSuffix\"] }, { kind: \"component\", type: i6.MatIcon, selector: \"mat-icon\", inputs: [\"color\", \"inline\", \"svgIcon\", \"fontSet\", \"fontIcon\"], exportAs: [\"matIcon\"] }, { kind: \"directive\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: [\"address\", \"country\", \"placeIdOnly\", \"strictBounds\", \"types\", \"type\", \"autoCompleteOptions\", \"value\"], outputs: [\"onChange\", \"onAutocompleteSelected\", \"onGermanAddressMapped\", \"onLocationSelected\"], exportAs: [\"matGoogleMapsAutocomplete\"] }], animations: InputAnimations });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-search-google-maps-autocomplete', animations: InputAnimations, providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\" }]\n        }], ctorParameters: function () { return [{ type: i1$1.UntypedFormBuilder }]; }, propDecorators: { searchBarAppearance: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], searchAddressLabel: [{\n                type: Input\n            }], streetNameLabel: [{\n                type: Input\n            }], streetNumberLabel: [{\n                type: Input\n            }], postalCodeLabel: [{\n                type: Input\n            }], localityLabel: [{\n                type: Input\n            }], vicinityLabel: [{\n                type: Input\n            }], showVicinity: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }], disableSearch: [{\n                type: Input\n            }], _value: [{\n                type: Input\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }] } });","originalLength":47427,"removedExports":[],"renderedExports":["MatSearchGoogleMapsAutocompleteComponent"],"renderedLength":21074},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/component/index.mjs":{"code":"","originalLength":769,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/lib/mat-google-maps-autocomplete.module.mjs":{"code":"class MatGoogleMapsAutocompleteModule {\n    constructor() {\n    }\n    static forRoot(apiKey) {\n        return {\n            ngModule: MatGoogleMapsAutocompleteModule,\n            providers: [\n                {\n                    provide: ApiKeyToken,\n                    useValue: apiKey\n                },\n            ]\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, declarations: [MatGoogleMapsAutocompleteComponent,\n            MatGoogleMapsAutocompleteDirective,\n            MatValidateAddressDirective,\n            MatSearchGoogleMapsAutocompleteComponent], imports: [CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule], exports: [MatGoogleMapsAutocompleteComponent,\n            MatGoogleMapsAutocompleteDirective,\n            MatValidateAddressDirective,\n            MatSearchGoogleMapsAutocompleteComponent] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, imports: [CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule,\n                        ReactiveFormsModule,\n                        FlexLayoutModule,\n                        MatInputModule,\n                        MatIconModule\n                    ],\n                    exports: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    declarations: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    providers: [\n                    // {\n                    //   provide: NG_VALUE_ACCESSOR,\n                    //   useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                    //   multi: true\n                    // }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });","originalLength":8438,"removedExports":[],"renderedExports":["MatGoogleMapsAutocompleteModule"],"renderedLength":2963},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of google-maps-autocomplete\n */","originalLength":1518,"removedExports":[],"renderedExports":[],"renderedLength":56},"/Users/anthonynahas/git/google-maps-autocomplete/dist/angular-material-extensions/google-maps-autocomplete/esm2022/angular-material-extensions-google-maps-autocomplete.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":668,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Directive, EventEmitter, Component, ViewChild, Input, Output, Injectable, PLATFORM_ID, Inject, HostListener, NgModule } from '@angular/core';\nimport * as i1$1 from '@angular/forms';\nimport { NG_VALIDATORS, UntypedFormControl, Validators, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport * as i1 from '@agm/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i4 from '@angular/material/input';\nimport { MatInputModule } from '@angular/material/input';\nimport * as i5 from '@angular/material/form-field';\nimport { animation, style, animate, trigger, transition, useAnimation, state, query, stagger, animateChild } from '@angular/animations';\nimport { distinctUntilChanged, debounceTime, takeUntil } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport * as i3 from '@angular/flex-layout/flex';\nimport * as i6 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport { FlexLayoutModule } from '@angular/flex-layout';\n\nfunction parseGermanAddress(placeResult) {\n    const germanAddress = {\n        gmID: placeResult.id,\n        icon: placeResult.icon,\n        url: placeResult.url,\n        placeID: placeResult.place_id,\n        displayAddress: placeResult.formatted_address,\n        name: placeResult.name,\n        vicinity: placeResult.vicinity,\n        locality: {},\n        state: {},\n        country: {},\n        geoLocation: { latitude: -1, longitude: -1 },\n    };\n    if (placeResult.geometry && placeResult.geometry.location) {\n        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n    }\n    if (placeResult.address_components && placeResult.address_components.length > 0) {\n        placeResult.address_components.forEach(value => {\n            if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n            }\n            if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n            }\n            if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n            }\n            if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n            }\n            if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n            }\n            if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n            }\n        });\n    }\n    return germanAddress;\n}\n\nconst ApiKeyToken = new InjectionToken('apiKey');\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\nclass MatValidateAddressDirective {\n    subscription;\n    _address;\n    constructor() {\n    }\n    validate() {\n        return (control) => {\n            return this.address ? null : {\n                validateAddress: {\n                    valid: false\n                }\n            };\n        };\n    }\n    subscribe(eventEmitter) {\n        this.subscription = eventEmitter.subscribe((address) => {\n            this.address = address;\n        });\n    }\n    unsubscribe() {\n        this.subscription.unsubscribe();\n    }\n    get address() {\n        return this._address;\n    }\n    set address(value) {\n        this._address = value;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatValidateAddressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\", providers: [\n            { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n        ], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatValidateAddressDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n                    providers: [\n                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });\n\nvar Appearance;\n(function (Appearance) {\n    Appearance[\"STANDARD\"] = \"standard\";\n    Appearance[\"FILL\"] = \"fill\";\n    Appearance[\"OUTLINE\"] = \"outline\";\n    Appearance[\"LEGACY\"] = \"legacy\";\n})(Appearance || (Appearance = {}));\nclass MatGoogleMapsAutocompleteComponent {\n    mapsAPILoader;\n    ngZone;\n    searchElementRef;\n    addressLabelText = 'Address';\n    placeholderText = 'Please enter the address';\n    requiredErrorText = 'The address is required';\n    invalidErrorText = 'The address is not valid';\n    appearance = Appearance.STANDARD;\n    value;\n    address;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    // types: string[] = ['address'];\n    type;\n    autoCompleteOptions = {};\n    onChange = new EventEmitter();\n    onAutocompleteSelected = new EventEmitter();\n    onGermanAddressMapped = new EventEmitter();\n    onLocationSelected = new EventEmitter();\n    onNewPlaceResult = new EventEmitter();\n    addressValidator = new MatValidateAddressDirective();\n    addressSearchControl = new UntypedFormControl({ value: null }, Validators.compose([\n        Validators.required,\n        this.addressValidator.validate()\n    ]));\n    propagateChange = (_) => {\n    };\n    constructor(mapsAPILoader, ngZone) {\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n    }\n    ngOnInit() {\n        this.addressValidator.subscribe(this.onNewPlaceResult);\n        const options = {\n            // types: ['address'],\n            // componentRestrictions: {country: this.country},\n            placeIdOnly: this.placeIdOnly,\n            strictBounds: this.strictBounds,\n            // types: this.types,\n            type: this.type\n        };\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.componentRestrictions = { country: this.country } : null;\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.types = this.types : null;\n        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n        this.initGoogleMapsAutocomplete();\n    }\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then(() => {\n            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', () => {\n                this.ngZone.run(() => {\n                    // get the place result\n                    const place = autocomplete.getPlace();\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    if (place.address_components) {\n                        place.address_components.forEach(value => {\n                            if (value.types.indexOf('street_number') > -1) {\n                                germanAddress.streetNumber = value.short_name;\n                            }\n                            if (value.types.indexOf('route') > -1) {\n                                germanAddress.streetName = value.long_name;\n                            }\n                            if (value.types.indexOf('postal_code') > -1) {\n                                germanAddress.postalCode = Number(value.short_name);\n                            }\n                            if (value.types.indexOf('sublocality') > -1) {\n                                germanAddress.sublocality = value.long_name;\n                            }\n                            if (value.types.indexOf('locality') > -1) {\n                                germanAddress.locality.long = value.long_name;\n                                germanAddress.locality.short = value.short_name;\n                            }\n                            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                                germanAddress.state.long = value.long_name;\n                                germanAddress.state.short = value.short_name;\n                            }\n                            if (value.types.indexOf('country') > -1) {\n                                germanAddress.country.long = value.long_name;\n                                germanAddress.country.short = value.short_name;\n                            }\n                            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                                germanAddress.locality.short = value.short_name;\n                            }\n                        });\n                    }\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                        this.value = place;\n                        this.propagateChange(this.value);\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                });\n            });\n        })\n            .catch((err) => console.log(err));\n    }\n    onQuery(event) {\n        this.onChange.emit(this.address);\n    }\n    resetAddress() {\n        this.address = null;\n        this.addressSearchControl.updateValueAndValidity();\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n        throw new Error('Method not implemented.');\n    }\n    setDisabledState(isDisabled) {\n        throw new Error('Method not implemented.');\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i1.MapsAPILoader }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatGoogleMapsAutocompleteComponent, selector: \"mat-google-maps-autocomplete\", inputs: { addressLabelText: \"addressLabelText\", placeholderText: \"placeholderText\", requiredErrorText: \"requiredErrorText\", invalidErrorText: \"invalidErrorText\", appearance: \"appearance\", value: \"value\", address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                multi: true\n            }\n        ], viewQueries: [{ propertyName: \"searchElementRef\", first: true, predicate: [\"search\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0, template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { kind: \"directive\", type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { kind: \"directive\", type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { kind: \"directive\", type: i1$1.NgModel, selector: \"[ngModel]:not([formControlName]):not([formControl])\", inputs: [\"name\", \"disabled\", \"ngModel\", \"ngModelOptions\"], outputs: [\"ngModelChange\"], exportAs: [\"ngModel\"] }, { kind: \"directive\", type: i4.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { kind: \"component\", type: i5.MatFormField, selector: \"mat-form-field\", inputs: [\"hideRequiredMarker\", \"color\", \"floatLabel\", \"appearance\", \"subscriptSizing\", \"hintLabel\"], exportAs: [\"matFormField\"] }, { kind: \"directive\", type: i5.MatLabel, selector: \"mat-label\" }, { kind: \"directive\", type: i5.MatError, selector: \"mat-error, [matError]\", inputs: [\"id\"] }, { kind: \"directive\", type: MatValidateAddressDirective, selector: \"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]\" }] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\", styles: [\".full-width{width:100%}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: i1.MapsAPILoader }, { type: i0.NgZone }]; }, propDecorators: { searchElementRef: [{\n                type: ViewChild,\n                args: ['search']\n            }], addressLabelText: [{\n                type: Input\n            }], placeholderText: [{\n                type: Input\n            }], requiredErrorText: [{\n                type: Input\n            }], invalidErrorText: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }] } });\n\nconst customAnimation = animation([\n    style({\n        opacity: '{{opacity}}',\n        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n], {\n    params: {\n        duration: '200ms',\n        delay: '0ms',\n        opacity: '0',\n        scale: '1',\n        x: '0',\n        y: '0',\n        z: '0'\n    }\n});\nconst InputAnimations = [\n    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n    trigger('animateStagger', [\n        state('50', style('*')),\n        state('100', style('*')),\n        state('200', style('*')),\n        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),\n        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),\n        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))\n    ]),\n];\n\nclass ScriptLoaderService {\n    loadedScripts = {};\n    scriptPromises = {}; // Neu\n    loadScript(src) {\n        // Wenn das Skript bereits erfolgreich geladen wurde, sofort auflösen\n        if (this.loadedScripts[src]) {\n            return Promise.resolve();\n        }\n        // Wenn ein Ladevorgang für dieses Skript bereits im Gange ist, das vorhandene Promise zurückgeben\n        if (this.scriptPromises[src]) {\n            return this.scriptPromises[src];\n        }\n        // Ein neues Promise für das Skript-Laden erstellen und speichern\n        this.scriptPromises[src] = new Promise((resolve, reject) => {\n            const script = document.createElement('script');\n            script.src = src;\n            script.async = true; // Empfohlen für externe Skripte\n            script.onload = () => {\n                this.loadedScripts[src] = true; // Markiere das Skript als geladen\n                resolve();\n            };\n            script.onerror = (error) => {\n                this.scriptPromises[src] = null; // Bei Fehler, entferne das Promise, damit erneute Versuche möglich sind\n                reject(error);\n            };\n            document.body.appendChild(script);\n        });\n        return this.scriptPromises[src];\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: ScriptLoaderService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\nclass MatGoogleMapsAutocompleteDirective {\n    platformId;\n    apiKey;\n    elemRef;\n    cf;\n    loaderService;\n    ngZone;\n    inputField;\n    autocomplete;\n    address;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    type;\n    autoCompleteOptions = {};\n    onChange = new EventEmitter();\n    onAutocompleteSelected = new EventEmitter();\n    onGermanAddressMapped = new EventEmitter();\n    onLocationSelected = new EventEmitter();\n    disabled;\n    _value;\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n        this.cf.markForCheck();\n    }\n    onNewPlaceResult = new EventEmitter();\n    propagateChange = (_) => {\n    };\n    constructor(platformId, apiKey, elemRef, cf, loaderService, ngZone) {\n        this.platformId = platformId;\n        this.apiKey = apiKey;\n        this.elemRef = elemRef;\n        this.cf = cf;\n        this.loaderService = loaderService;\n        this.ngZone = ngZone;\n    }\n    ngOnDestroy() {\n        throw new Error('Method not implemented.');\n    }\n    ngAfterViewInit() {\n        this.loadMap();\n    }\n    ngOnInit() {\n        console.log(\"this.apiKey = \", this.apiKey);\n    }\n    validate(fc) {\n        return fc.hasValidator(Validators.required) ? !!fc?.value : true;\n    }\n    onChangeInputValue() {\n        const value = this.elemRef.nativeElement?.value;\n        this.value = value;\n    }\n    initGoogleMapsAutocomplete() {\n        const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n            this.ngZone.run(() => {\n                // get the place result\n                const place = autocomplete.getPlace();\n                const germanAddress = {\n                    gmID: place.id,\n                    icon: place.icon,\n                    url: place.url,\n                    placeID: place.place_id,\n                    displayAddress: place.formatted_address,\n                    name: place.name,\n                    vicinity: place.vicinity,\n                    locality: {},\n                    state: {},\n                    country: {},\n                    geoLocation: { latitude: -1, longitude: -1 },\n                };\n                if (place.geometry && place.geometry.location) {\n                    germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                    germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                }\n                place.address_components.forEach(value => {\n                    if (value.types.indexOf('street_number') > -1) {\n                        germanAddress.streetNumber = value.short_name;\n                    }\n                    if (value.types.indexOf('route') > -1) {\n                        germanAddress.streetName = value.long_name;\n                    }\n                    if (value.types.indexOf('postal_code') > -1) {\n                        germanAddress.postalCode = Number(value.short_name);\n                    }\n                    if (value.types.indexOf('sublocality') > -1) {\n                        germanAddress.sublocality = value.long_name;\n                    }\n                    if (value.types.indexOf('locality') > -1) {\n                        germanAddress.locality.long = value.long_name;\n                        germanAddress.locality.short = value.short_name;\n                    }\n                    if (value.types.indexOf('administrative_area_level_1') > -1) {\n                        germanAddress.state.long = value.long_name;\n                        germanAddress.state.short = value.short_name;\n                    }\n                    if (value.types.indexOf('country') > -1) {\n                        germanAddress.country.long = value.long_name;\n                        germanAddress.country.short = value.short_name;\n                    }\n                    if (value.types.indexOf('administrative_area_level_3') > -1) {\n                        germanAddress.locality.short = value.short_name;\n                    }\n                });\n                this.onGermanAddressMapped.emit(germanAddress);\n                this.value = place.formatted_address;\n                this.address = place.formatted_address;\n                this.onAutocompleteSelected.emit(place);\n                this.onLocationSelected.emit({\n                    latitude: place.geometry.location.lat(),\n                    longitude: place.geometry.location.lng()\n                });\n            });\n        });\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    writeValue(obj) {\n        if (obj) {\n            this.value = obj;\n        }\n    }\n    loadMap() {\n        this.loaderService.loadScript(`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=places`)\n            .then(() => {\n            this.initMap();\n        })\n            .catch(error => console.error('Google Maps loading failed: ', error));\n    }\n    initMap() {\n        if (isPlatformBrowser(this.platformId)) {\n            console.log(\"on after view init --> \", this.elemRef.nativeElement);\n            this.autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement);\n            const options = {\n                // types: ['address'],\n                // componentRestrictions: {country: this.country},\n                placeIdOnly: this.placeIdOnly,\n                strictBounds: this.strictBounds,\n                // types: this.types,\n                type: this.type\n            };\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.componentRestrictions = { country: this.country } : null;\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.types = this.types : null;\n            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n            this.initGoogleMapsAutocomplete();\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, deps: [{ token: PLATFORM_ID }, { token: ApiKeyToken }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: ScriptLoaderService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: { address: \"address\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", autoCompleteOptions: \"autoCompleteOptions\", value: \"value\" }, outputs: { onChange: \"onChange\", onAutocompleteSelected: \"onAutocompleteSelected\", onGermanAddressMapped: \"onGermanAddressMapped\", onLocationSelected: \"onLocationSelected\" }, host: { listeners: { \"change\": \"onChangeInputValue()\" } }, providers: [\n            {\n                provide: NG_VALIDATORS,\n                useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                multi: true\n            }\n        ], viewQueries: [{ propertyName: \"inputField\", first: true, predicate: [\"inputField\"], descendants: true }], exportAs: [\"matGoogleMapsAutocomplete\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matGoogleMapsAutocomplete]',\n                    exportAs: 'matGoogleMapsAutocomplete',\n                    providers: [\n                        {\n                            provide: NG_VALIDATORS,\n                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                            multi: true\n                        }\n                    ]\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [ApiKeyToken]\n                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: ScriptLoaderService }, { type: i0.NgZone }]; }, propDecorators: { inputField: [{\n                type: ViewChild,\n                args: ['inputField']\n            }], address: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], autoCompleteOptions: [{\n                type: Input\n            }], onChange: [{\n                type: Output\n            }], onAutocompleteSelected: [{\n                type: Output\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], onLocationSelected: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }], onChangeInputValue: [{\n                type: HostListener,\n                args: ['change']\n            }] } });\n\nclass MatSearchGoogleMapsAutocompleteComponent {\n    formBuilder;\n    constructor(formBuilder) {\n        this.formBuilder = formBuilder;\n        // Set the private defaults\n        this._unsubscribeAll = new Subject();\n    }\n    searchBarAppearance;\n    appearance = Appearance.STANDARD;\n    searchAddressLabel = 'Search Address';\n    streetNameLabel = 'Street';\n    streetNumberLabel = 'Nr.';\n    postalCodeLabel = 'PLZ';\n    localityLabel = 'Locality';\n    vicinityLabel = 'Vicinity';\n    showVicinity;\n    country;\n    placeIdOnly;\n    strictBounds;\n    types;\n    // types: string[] = ['address'];\n    type;\n    readonly;\n    disableSearch;\n    _value;\n    onGermanAddressMapped = new EventEmitter();\n    germanAddress;\n    addressFormGroup;\n    firstInit = true;\n    // Private\n    _unsubscribeAll;\n    propagateChange = (_) => {\n    };\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.propagateChange(this.value);\n    }\n    ngOnInit() {\n        this.createAddressFormGroup();\n        this.enableCustomInput();\n    }\n    createAddressFormGroup() {\n        this.addressFormGroup = this.formBuilder.group({\n            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n            locality: this.formBuilder.group({\n                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n            }),\n        });\n    }\n    enableCustomInput() {\n        this.addressFormGroup\n            .get('streetName')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetName => {\n            !this.value ? this.value = { streetName } : this.value.streetName = streetName;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('streetNumber')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(streetNumber => {\n            !this.value ? this.value = { streetNumber } : this.value.streetNumber = streetNumber;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('postalCode')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(postalCode => {\n            !this.value ? this.value = { postalCode } : this.value.postalCode = postalCode;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('vicinity')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(vicinity => {\n            !this.value ? this.value = { vicinity } : this.value.vicinity = vicinity;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n        this.addressFormGroup\n            .get('locality')\n            .valueChanges\n            .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\n            .subscribe(locality => {\n            !this.value ? this.value = { locality } : this.value.locality = locality;\n            this.value.displayAddress = this.parseDisplayAddress();\n            this.propagateChange(this.value);\n        });\n    }\n    parseDisplayAddress() {\n        return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`;\n    }\n    syncAutoComplete($event) {\n        if (this.germanAddress) {\n            this.addressFormGroup.reset();\n        }\n        const germanAddress = parseGermanAddress($event);\n        this.germanAddress = germanAddress;\n        if (germanAddress.vicinity) {\n            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetName) {\n            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.streetNumber) {\n            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.postalCode) {\n            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, { emitEvent: false, onlySelf: true });\n        }\n        if (germanAddress.locality && germanAddress.locality.long) {\n            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, { emitEvent: false, onlySelf: true });\n        }\n        this.value = germanAddress;\n        this.onGermanAddressMapped.emit(germanAddress);\n    }\n    writeValue(obj) {\n        let shouldRecreateFG = false;\n        if (obj) {\n            if (!this.value && this.firstInit) {\n                shouldRecreateFG = true;\n            }\n            this.value = obj;\n            if (shouldRecreateFG) {\n                this.createAddressFormGroup();\n                this.firstInit = false;\n            }\n        }\n    }\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    registerOnTouched(fn) {\n    }\n    setDisabledState(isDisabled) {\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, deps: [{ token: i1$1.UntypedFormBuilder }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.2.2\", type: MatSearchGoogleMapsAutocompleteComponent, selector: \"mat-search-google-maps-autocomplete\", inputs: { searchBarAppearance: \"searchBarAppearance\", appearance: \"appearance\", searchAddressLabel: \"searchAddressLabel\", streetNameLabel: \"streetNameLabel\", streetNumberLabel: \"streetNumberLabel\", postalCodeLabel: \"postalCodeLabel\", localityLabel: \"localityLabel\", vicinityLabel: \"vicinityLabel\", showVicinity: \"showVicinity\", country: \"country\", placeIdOnly: \"placeIdOnly\", strictBounds: \"strictBounds\", types: \"types\", type: \"type\", readonly: \"readonly\", disableSearch: \"disableSearch\", _value: \"_value\", value: \"value\" }, outputs: { onGermanAddressMapped: \"onGermanAddressMapped\" }, providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                multi: true\n            }\n        ], ngImport: i0, template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\", styles: [\"\"], dependencies: [{ kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i1$1.ɵNgNoValidate, selector: \"form:not([ngNoForm]):not([ngNativeValidate])\" }, { kind: \"directive\", type: i1$1.DefaultValueAccessor, selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\" }, { kind: \"directive\", type: i1$1.NumberValueAccessor, selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\" }, { kind: \"directive\", type: i1$1.NgControlStatus, selector: \"[formControlName],[ngModel],[formControl]\" }, { kind: \"directive\", type: i1$1.NgControlStatusGroup, selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\" }, { kind: \"directive\", type: i1$1.RequiredValidator, selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", inputs: [\"required\"] }, { kind: \"directive\", type: i1$1.FormGroupDirective, selector: \"[formGroup]\", inputs: [\"formGroup\"], outputs: [\"ngSubmit\"], exportAs: [\"ngForm\"] }, { kind: \"directive\", type: i1$1.FormControlName, selector: \"[formControlName]\", inputs: [\"formControlName\", \"disabled\", \"ngModel\"], outputs: [\"ngModelChange\"] }, { kind: \"directive\", type: i1$1.FormGroupName, selector: \"[formGroupName]\", inputs: [\"formGroupName\"] }, { kind: \"directive\", type: i3.DefaultLayoutDirective, selector: \"  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],  [fxLayout.gt-md], [fxLayout.gt-lg]\", inputs: [\"fxLayout\", \"fxLayout.xs\", \"fxLayout.sm\", \"fxLayout.md\", \"fxLayout.lg\", \"fxLayout.xl\", \"fxLayout.lt-sm\", \"fxLayout.lt-md\", \"fxLayout.lt-lg\", \"fxLayout.lt-xl\", \"fxLayout.gt-xs\", \"fxLayout.gt-sm\", \"fxLayout.gt-md\", \"fxLayout.gt-lg\"] }, { kind: \"directive\", type: i3.DefaultLayoutGapDirective, selector: \"  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\", inputs: [\"fxLayoutGap\", \"fxLayoutGap.xs\", \"fxLayoutGap.sm\", \"fxLayoutGap.md\", \"fxLayoutGap.lg\", \"fxLayoutGap.xl\", \"fxLayoutGap.lt-sm\", \"fxLayoutGap.lt-md\", \"fxLayoutGap.lt-lg\", \"fxLayoutGap.lt-xl\", \"fxLayoutGap.gt-xs\", \"fxLayoutGap.gt-sm\", \"fxLayoutGap.gt-md\", \"fxLayoutGap.gt-lg\"] }, { kind: \"directive\", type: i3.DefaultFlexDirective, selector: \"  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],  [fxFlex.gt-md], [fxFlex.gt-lg]\", inputs: [\"fxFlex\", \"fxFlex.xs\", \"fxFlex.sm\", \"fxFlex.md\", \"fxFlex.lg\", \"fxFlex.xl\", \"fxFlex.lt-sm\", \"fxFlex.lt-md\", \"fxFlex.lt-lg\", \"fxFlex.lt-xl\", \"fxFlex.gt-xs\", \"fxFlex.gt-sm\", \"fxFlex.gt-md\", \"fxFlex.gt-lg\"] }, { kind: \"directive\", type: i4.MatInput, selector: \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", inputs: [\"disabled\", \"id\", \"placeholder\", \"name\", \"required\", \"type\", \"errorStateMatcher\", \"aria-describedby\", \"value\", \"readonly\"], exportAs: [\"matInput\"] }, { kind: \"component\", type: i5.MatFormField, selector: \"mat-form-field\", inputs: [\"hideRequiredMarker\", \"color\", \"floatLabel\", \"appearance\", \"subscriptSizing\", \"hintLabel\"], exportAs: [\"matFormField\"] }, { kind: \"directive\", type: i5.MatLabel, selector: \"mat-label\" }, { kind: \"directive\", type: i5.MatSuffix, selector: \"[matSuffix], [matIconSuffix], [matTextSuffix]\", inputs: [\"matTextSuffix\"] }, { kind: \"component\", type: i6.MatIcon, selector: \"mat-icon\", inputs: [\"color\", \"inline\", \"svgIcon\", \"fontSet\", \"fontIcon\"], exportAs: [\"matIcon\"] }, { kind: \"directive\", type: MatGoogleMapsAutocompleteDirective, selector: \"[matGoogleMapsAutocomplete]\", inputs: [\"address\", \"country\", \"placeIdOnly\", \"strictBounds\", \"types\", \"type\", \"autoCompleteOptions\", \"value\"], outputs: [\"onChange\", \"onAutocompleteSelected\", \"onGermanAddressMapped\", \"onLocationSelected\"], exportAs: [\"matGoogleMapsAutocomplete\"] }], animations: InputAnimations });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatSearchGoogleMapsAutocompleteComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-search-google-maps-autocomplete', animations: InputAnimations, providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\n                            multi: true\n                        }\n                    ], template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\" }]\n        }], ctorParameters: function () { return [{ type: i1$1.UntypedFormBuilder }]; }, propDecorators: { searchBarAppearance: [{\n                type: Input\n            }], appearance: [{\n                type: Input\n            }], searchAddressLabel: [{\n                type: Input\n            }], streetNameLabel: [{\n                type: Input\n            }], streetNumberLabel: [{\n                type: Input\n            }], postalCodeLabel: [{\n                type: Input\n            }], localityLabel: [{\n                type: Input\n            }], vicinityLabel: [{\n                type: Input\n            }], showVicinity: [{\n                type: Input\n            }], country: [{\n                type: Input\n            }], placeIdOnly: [{\n                type: Input\n            }], strictBounds: [{\n                type: Input\n            }], types: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }], disableSearch: [{\n                type: Input\n            }], _value: [{\n                type: Input\n            }], onGermanAddressMapped: [{\n                type: Output\n            }], value: [{\n                type: Input\n            }] } });\n\nclass MatGoogleMapsAutocompleteModule {\n    constructor() {\n    }\n    static forRoot(apiKey) {\n        return {\n            ngModule: MatGoogleMapsAutocompleteModule,\n            providers: [\n                {\n                    provide: ApiKeyToken,\n                    useValue: apiKey\n                },\n            ]\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, declarations: [MatGoogleMapsAutocompleteComponent,\n            MatGoogleMapsAutocompleteDirective,\n            MatValidateAddressDirective,\n            MatSearchGoogleMapsAutocompleteComponent], imports: [CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule], exports: [MatGoogleMapsAutocompleteComponent,\n            MatGoogleMapsAutocompleteDirective,\n            MatValidateAddressDirective,\n            MatSearchGoogleMapsAutocompleteComponent] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, imports: [CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatIconModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.2\", ngImport: i0, type: MatGoogleMapsAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule,\n                        ReactiveFormsModule,\n                        FlexLayoutModule,\n                        MatInputModule,\n                        MatIconModule\n                    ],\n                    exports: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    declarations: [\n                        MatGoogleMapsAutocompleteComponent,\n                        MatGoogleMapsAutocompleteDirective,\n                        MatValidateAddressDirective,\n                        MatSearchGoogleMapsAutocompleteComponent\n                    ],\n                    providers: [\n                    // {\n                    //   provide: NG_VALUE_ACCESSOR,\n                    //   useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\n                    //   multi: true\n                    // }\n                    ]\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/*\n * Public API Surface of google-maps-autocomplete\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ApiKeyToken, Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatSearchGoogleMapsAutocompleteComponent, MatValidateAddressDirective, parseGermanAddress };\n//# sourceMappingURL=angular-material-extensions-google-maps-autocomplete.mjs.map\n","map":null,"preliminaryFileName":"angular-material-extensions-google-maps-autocomplete.mjs"},{"fileName":"angular-material-extensions-google-maps-autocomplete.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"angular-material-extensions-google-maps-autocomplete.mjs\",\"sources\":[\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/helpers/parser.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/tokens/index.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/address-validator/mat-address-validator.directive.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-google-maps-autocomplete.component.html\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/animations/index.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/services/script-loader.service.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/directives/mat-google-maps-autocomplete.directive.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.html\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/lib/mat-google-maps-autocomplete.module.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/public-api.ts\",\"../../../../projects/angular-material-extensions/google-maps-autocomplete/src/angular-material-extensions-google-maps-autocomplete.ts\"],\"sourcesContent\":[\"import PlaceResult = google.maps.places.PlaceResult;\\nimport {GermanAddress} from '../interfaces';\\n\\nexport function parseGermanAddress(placeResult: PlaceResult): GermanAddress {\\n  const germanAddress: GermanAddress = {\\n    gmID: placeResult.id,\\n    icon: placeResult.icon,\\n    url: placeResult.url,\\n    placeID: placeResult.place_id,\\n    displayAddress: placeResult.formatted_address,\\n    name: placeResult.name,\\n    vicinity: placeResult.vicinity,\\n    locality: {},\\n    state: {},\\n    country: {},\\n    geoLocation: {latitude: -1, longitude: -1},\\n  };\\n\\n  if (placeResult.geometry && placeResult.geometry.location) {\\n    germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\\n    germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\\n  }\\n\\n  if (placeResult.address_components && placeResult.address_components.length > 0) {\\n    placeResult.address_components.forEach(value => {\\n      if (value.types.indexOf('street_number') > -1) {\\n        germanAddress.streetNumber = value.short_name;\\n      }\\n      if (value.types.indexOf('route') > -1) {\\n        germanAddress.streetName = value.long_name;\\n      }\\n      if (value.types.indexOf('postal_code') > -1) {\\n        germanAddress.postalCode = Number(value.short_name);\\n      }\\n      if (value.types.indexOf('sublocality') > -1) {\\n        germanAddress.sublocality = value.long_name;\\n      }\\n      if (value.types.indexOf('locality') > -1) {\\n        germanAddress.locality.long = value.long_name;\\n        germanAddress.locality.short = value.short_name;\\n      }\\n      if (value.types.indexOf('administrative_area_level_1') > -1) {\\n        germanAddress.state.long = value.long_name;\\n        germanAddress.state.short = value.short_name;\\n      }\\n      if (value.types.indexOf('country') > -1) {\\n        germanAddress.country.long = value.long_name;\\n        germanAddress.country.short = value.short_name;\\n      }\\n      if (value.types.indexOf('administrative_area_level_3') > -1) {\\n        germanAddress.locality.short = value.short_name;\\n      }\\n    });\\n  }\\n  return germanAddress;\\n}\\n\",\"import {InjectionToken} from \\\"@angular/core\\\";\\n\\nexport const ApiKeyToken = new InjectionToken<string>('apiKey');\\n\",\"import {Directive, EventEmitter, forwardRef} from '@angular/core';\\nimport {AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn} from '@angular/forms';\\nimport PlaceResult = google.maps.places.PlaceResult;\\n\\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\\n\\n@Directive({\\n  selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\\n  providers: [\\n    {provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true}\\n  ]\\n})\\nexport class MatValidateAddressDirective implements Validator {\\n\\n  public subscription: any;\\n\\n  private _address: PlaceResult;\\n\\n\\n  constructor() {\\n  }\\n\\n  public validate(): ValidatorFn {\\n    return (control: AbstractControl): ValidationErrors | any => {\\n      return this.address ? null : {\\n        validateAddress: {\\n          valid: false\\n        }\\n      };\\n    }\\n  }\\n\\n  public subscribe(eventEmitter: EventEmitter<any>) {\\n    this.subscription = eventEmitter.subscribe((address: PlaceResult) => {\\n      this.address = address;\\n    });\\n  }\\n\\n  public unsubscribe() {\\n    this.subscription.unsubscribe();\\n  }\\n\\n  get address() {\\n    return this._address;\\n  }\\n\\n  set address(value) {\\n    this._address = value;\\n  }\\n}\\n\",\"import {Component, ElementRef, EventEmitter, forwardRef, Input, NgZone, OnInit, Output, ViewChild} from '@angular/core';\\nimport {ControlValueAccessor, UntypedFormControl, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\\nimport {MapsAPILoader} from '@agm/core';\\nimport {MatValidateAddressDirective} from '../directives/address-validator/mat-address-validator.directive';\\nimport {Location} from '../interfaces/location.interface';\\nimport {GermanAddress} from '../interfaces';\\n\\nimport PlaceResult = google.maps.places.PlaceResult;\\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\\n\\nexport enum Appearance {\\n  STANDARD = 'standard',\\n  FILL = 'fill',\\n  OUTLINE = 'outline',\\n  LEGACY = 'legacy',\\n}\\n\\n@Component({\\n  selector: 'mat-google-maps-autocomplete',\\n  exportAs: 'matGoogleMapsAutocomplete',\\n  templateUrl: './mat-google-maps-autocomplete.component.html',\\n  styleUrls: ['./mat-google-maps-autocomplete.component.scss'],\\n  providers: [\\n    {\\n      provide: NG_VALUE_ACCESSOR,\\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),\\n      multi: true\\n    }\\n  ]\\n})\\nexport class MatGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\\n\\n  @ViewChild('search')\\n  public searchElementRef: ElementRef;\\n\\n  @Input()\\n  addressLabelText = 'Address';\\n\\n  @Input()\\n  placeholderText = 'Please enter the address';\\n\\n  @Input()\\n  requiredErrorText = 'The address is required';\\n\\n  @Input()\\n  invalidErrorText = 'The address is not valid';\\n\\n  @Input()\\n  appearance: string | Appearance = Appearance.STANDARD;\\n\\n  @Input()\\n  value: PlaceResult;\\n\\n  @Input()\\n  address: PlaceResult | string;\\n\\n  @Input()\\n  country: string | string[];\\n\\n  @Input()\\n  placeIdOnly?: boolean;\\n\\n  @Input()\\n  strictBounds?: boolean;\\n\\n  @Input()\\n  types?: string[];\\n  // types: string[] = ['address'];\\n\\n  @Input()\\n  type?: string;\\n\\n  @Input()\\n  autoCompleteOptions: AutocompleteOptions = {};\\n\\n  @Output()\\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\\n\\n  @Output()\\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\\n\\n  @Output()\\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\\n\\n  @Output()\\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\\n\\n\\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\\n  private addressValidator: MatValidateAddressDirective = new MatValidateAddressDirective();\\n\\n  public addressSearchControl: UntypedFormControl = new UntypedFormControl({value: null}, Validators.compose([\\n    Validators.required,\\n    this.addressValidator.validate()])\\n  );\\n\\n  propagateChange = (_: any) => {\\n  };\\n\\n  constructor(private mapsAPILoader: MapsAPILoader,\\n              private ngZone: NgZone) {\\n  }\\n\\n  ngOnInit(): void {\\n    this.addressValidator.subscribe(this.onNewPlaceResult);\\n\\n    const options: AutocompleteOptions = {\\n      // types: ['address'],\\n      // componentRestrictions: {country: this.country},\\n      placeIdOnly: this.placeIdOnly,\\n      strictBounds: this.strictBounds,\\n      // types: this.types,\\n      type: this.type\\n    };\\n\\n    // tslint:disable-next-line:no-unused-expression\\n    this.country ? options.componentRestrictions = {country: this.country} : null;\\n    // tslint:disable-next-line:no-unused-expression\\n    this.country ? options.types = this.types : null;\\n\\n    this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\\n    this.initGoogleMapsAutocomplete();\\n  }\\n\\n  public initGoogleMapsAutocomplete() {\\n    this.mapsAPILoader\\n      .load()\\n      .then(() => {\\n        const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\\n        autocomplete.addListener('place_changed', () => {\\n          this.ngZone.run(() => {\\n            // get the place result\\n            const place: PlaceResult = autocomplete.getPlace();\\n\\n            const germanAddress: GermanAddress = {\\n              gmID: place.id,\\n              icon: place.icon,\\n              url: place.url,\\n              placeID: place.place_id,\\n              displayAddress: place.formatted_address,\\n              name: place.name,\\n              vicinity: place.vicinity,\\n              locality: {},\\n              state: {},\\n              country: {},\\n              geoLocation: {latitude: -1, longitude: -1},\\n            };\\n\\n            if (place.geometry && place.geometry.location) {\\n              germanAddress.geoLocation.latitude = place.geometry.location.lat();\\n              germanAddress.geoLocation.longitude = place.geometry.location.lng();\\n            }\\n\\n            if(place.address_components) {\\n              place.address_components.forEach(value => {\\n                if (value.types.indexOf('street_number') > -1) {\\n                  germanAddress.streetNumber = value.short_name;\\n                }\\n                if (value.types.indexOf('route') > -1) {\\n                  germanAddress.streetName = value.long_name;\\n                }\\n                if (value.types.indexOf('postal_code') > -1) {\\n                  germanAddress.postalCode = Number(value.short_name);\\n                }\\n                if (value.types.indexOf('sublocality') > -1) {\\n                  germanAddress.sublocality = value.long_name;\\n                }\\n                if (value.types.indexOf('locality') > -1) {\\n                  germanAddress.locality.long = value.long_name;\\n                  germanAddress.locality.short = value.short_name;\\n                }\\n                if (value.types.indexOf('administrative_area_level_1') > -1) {\\n                  germanAddress.state.long = value.long_name;\\n                  germanAddress.state.short = value.short_name;\\n                }\\n                if (value.types.indexOf('country') > -1) {\\n                  germanAddress.country.long = value.long_name;\\n                  germanAddress.country.short = value.short_name;\\n                }\\n                if (value.types.indexOf('administrative_area_level_3') > -1) {\\n                  germanAddress.locality.short = value.short_name;\\n                }\\n              });\\n            }\\n\\n            this.onGermanAddressMapped.emit(germanAddress);\\n\\n            if (!place.place_id || place.geometry === undefined || place.geometry === null) {\\n              // place result is not valid\\n              return;\\n            } else {\\n              // show dialog to select a address from the input\\n              // emit failed event\\n              this.value = place;\\n              this.propagateChange(this.value)\\n            }\\n            this.address = place.formatted_address;\\n            this.onAutocompleteSelected.emit(place);\\n            this.onLocationSelected.emit(\\n              {\\n                latitude: place.geometry.location.lat(),\\n                longitude: place.geometry.location.lng()\\n              });\\n          });\\n        });\\n      })\\n      .catch((err) => console.log(err));\\n  }\\n\\n  public onQuery(event: any) {\\n    this.onChange.emit(this.address);\\n  }\\n\\n  private resetAddress() {\\n    this.address = null;\\n    this.addressSearchControl.updateValueAndValidity();\\n  }\\n\\n  writeValue(obj: any): void {\\n    if (obj) {\\n      this.value = obj;\\n    }\\n  }\\n\\n  registerOnChange(fn: any): void {\\n    this.propagateChange = fn;\\n  }\\n\\n  registerOnTouched(fn: any): void {\\n    throw new Error('Method not implemented.');\\n  }\\n\\n  setDisabledState?(isDisabled: boolean): void {\\n    throw new Error('Method not implemented.');\\n  }\\n\\n}\\n\",\"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\",\"import {animate, animateChild, animation, query, stagger, state, style, transition, trigger, useAnimation} from '@angular/animations';\\n\\nconst customAnimation = animation(\\n  [\\n    style({\\n      opacity: '{{opacity}}',\\n      transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\\n    }),\\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\\n  ],\\n  {\\n    params: {\\n      duration: '200ms',\\n      delay: '0ms',\\n      opacity: '0',\\n      scale: '1',\\n      x: '0',\\n      y: '0',\\n      z: '0'\\n    }\\n  }\\n);\\n\\nexport const InputAnimations = [\\n  trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\\n\\n  trigger('animateStagger', [\\n    state('50', style('*')),\\n    state('100', style('*')),\\n    state('200', style('*')),\\n\\n    transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], {optional: true})),\\n    transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], {optional: true})),\\n    transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], {optional: true}))\\n  ]),\\n];\\n\",\"import {Injectable} from '@angular/core';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class ScriptLoaderService {\\n  private loadedScripts: { [src: string]: boolean } = {};\\n  private scriptPromises: { [src: string]: Promise<void> } = {}; // Neu\\n\\n  loadScript(src: string): Promise<void> {\\n    // Wenn das Skript bereits erfolgreich geladen wurde, sofort auflösen\\n    if (this.loadedScripts[src]) {\\n      return Promise.resolve();\\n    }\\n\\n    // Wenn ein Ladevorgang für dieses Skript bereits im Gange ist, das vorhandene Promise zurückgeben\\n    if (this.scriptPromises[src]) {\\n      return this.scriptPromises[src];\\n    }\\n\\n    // Ein neues Promise für das Skript-Laden erstellen und speichern\\n    this.scriptPromises[src] = new Promise((resolve, reject) => {\\n      const script = document.createElement('script');\\n      script.src = src;\\n      script.async = true; // Empfohlen für externe Skripte\\n      script.onload = () => {\\n        this.loadedScripts[src] = true; // Markiere das Skript als geladen\\n        resolve();\\n      };\\n      script.onerror = (error: any) => {\\n        this.scriptPromises[src] = null; // Bei Fehler, entferne das Promise, damit erneute Versuche möglich sind\\n        reject(error);\\n      };\\n      document.body.appendChild(script);\\n    });\\n\\n    return this.scriptPromises[src];\\n  }\\n}\\n\",\"import {\\n  AfterViewInit,\\n  ChangeDetectorRef,\\n  Directive,\\n  ElementRef,\\n  EventEmitter,\\n  forwardRef,\\n  HostListener,\\n  Inject,\\n  Input,\\n  NgZone,\\n  OnDestroy,\\n  OnInit,\\n  Output,\\n  PLATFORM_ID,\\n  ViewChild\\n} from '@angular/core';\\nimport {ControlValueAccessor, FormControl, NG_VALIDATORS, Validators} from '@angular/forms';\\nimport {GermanAddress, Location} from '../interfaces';\\nimport {isPlatformBrowser} from '@angular/common';\\nimport {ScriptLoaderService} from \\\"../services/script-loader.service\\\";\\nimport {ApiKeyToken} from \\\"../tokens\\\";\\nimport PlaceResult = google.maps.places.PlaceResult;\\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\\n\\n@Directive({\\n  selector: '[matGoogleMapsAutocomplete]',\\n  exportAs: 'matGoogleMapsAutocomplete',\\n  providers: [\\n    {\\n      provide: NG_VALIDATORS,\\n      useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\\n      multi: true\\n    }\\n  ]\\n})\\nexport class MatGoogleMapsAutocompleteDirective implements OnInit, AfterViewInit, OnDestroy, ControlValueAccessor {\\n\\n  @ViewChild('inputField')\\n  inputField!: ElementRef;\\n\\n  autocomplete: google.maps.places.Autocomplete | undefined;\\n\\n  @Input()\\n  address: PlaceResult | string;\\n\\n  @Input()\\n  country: string | string[];\\n\\n  @Input()\\n  placeIdOnly?: boolean;\\n\\n  @Input()\\n  strictBounds?: boolean;\\n\\n  @Input()\\n  types?: string[];\\n\\n  @Input()\\n  type?: string;\\n\\n  @Input()\\n  autoCompleteOptions: AutocompleteOptions = {};\\n\\n  @Output()\\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\\n\\n  @Output()\\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\\n\\n  @Output()\\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\\n\\n  @Output()\\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\\n\\n  disabled: boolean\\n\\n  _value: string;\\n\\n  get value(): string {\\n    return this._value;\\n  }\\n\\n  @Input()\\n  set value(value: string) {\\n    this._value = value;\\n    this.propagateChange(this.value);\\n    this.cf.markForCheck();\\n  }\\n\\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\\n\\n  propagateChange = (_: any) => {\\n  };\\n\\n  constructor(@Inject(PLATFORM_ID) public platformId: string,\\n              @Inject(ApiKeyToken)\\n              public apiKey: string,\\n              public elemRef: ElementRef,\\n              private cf: ChangeDetectorRef,\\n              private loaderService: ScriptLoaderService,\\n              private ngZone: NgZone) {\\n  }\\n\\n  ngOnDestroy(): void {\\n    throw new Error('Method not implemented.');\\n  }\\n\\n  ngAfterViewInit(): void {\\n    this.loadMap();\\n  }\\n\\n  ngOnInit(): void {\\n    console.log(\\\"this.apiKey = \\\", this.apiKey)\\n  }\\n\\n  validate(fc: FormControl) {\\n    return fc.hasValidator(Validators.required) ? !!fc?.value : true;\\n  }\\n\\n  @HostListener('change')\\n  onChangeInputValue(): void {\\n    const value = (this.elemRef.nativeElement as HTMLInputElement)?.value;\\n    this.value = value;\\n  }\\n\\n  public initGoogleMapsAutocomplete() {\\n    const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\\n    autocomplete.addListener('place_changed', () => {\\n      this.ngZone.run(() => {\\n        // get the place result\\n        const place: PlaceResult = autocomplete.getPlace();\\n\\n        const germanAddress: GermanAddress = {\\n          gmID: place.id,\\n          icon: place.icon,\\n          url: place.url,\\n          placeID: place.place_id,\\n          displayAddress: place.formatted_address,\\n          name: place.name,\\n          vicinity: place.vicinity,\\n          locality: {},\\n          state: {},\\n          country: {},\\n          geoLocation: {latitude: -1, longitude: -1},\\n        };\\n\\n        if (place.geometry && place.geometry.location) {\\n          germanAddress.geoLocation.latitude = place.geometry.location.lat();\\n          germanAddress.geoLocation.longitude = place.geometry.location.lng();\\n        }\\n\\n        place.address_components.forEach(value => {\\n          if (value.types.indexOf('street_number') > -1) {\\n            germanAddress.streetNumber = value.short_name;\\n          }\\n          if (value.types.indexOf('route') > -1) {\\n            germanAddress.streetName = value.long_name;\\n          }\\n          if (value.types.indexOf('postal_code') > -1) {\\n            germanAddress.postalCode = Number(value.short_name);\\n          }\\n          if (value.types.indexOf('sublocality') > -1) {\\n            germanAddress.sublocality = value.long_name;\\n          }\\n          if (value.types.indexOf('locality') > -1) {\\n            germanAddress.locality.long = value.long_name;\\n            germanAddress.locality.short = value.short_name;\\n          }\\n          if (value.types.indexOf('administrative_area_level_1') > -1) {\\n            germanAddress.state.long = value.long_name;\\n            germanAddress.state.short = value.short_name;\\n          }\\n          if (value.types.indexOf('country') > -1) {\\n            germanAddress.country.long = value.long_name;\\n            germanAddress.country.short = value.short_name;\\n          }\\n          if (value.types.indexOf('administrative_area_level_3') > -1) {\\n            germanAddress.locality.short = value.short_name;\\n          }\\n        });\\n\\n        this.onGermanAddressMapped.emit(germanAddress);\\n\\n        this.value = place.formatted_address;\\n        this.address = place.formatted_address;\\n        this.onAutocompleteSelected.emit(place);\\n        this.onLocationSelected.emit(\\n          {\\n            latitude: place.geometry.location.lat(),\\n            longitude: place.geometry.location.lng()\\n          });\\n      });\\n    });\\n  }\\n\\n  registerOnChange(fn: any): void {\\n    this.propagateChange = fn;\\n  }\\n\\n  registerOnTouched(fn: any): void {\\n  }\\n\\n  setDisabledState(isDisabled: boolean): void {\\n    this.disabled = isDisabled;\\n  }\\n\\n  writeValue(obj: any): void {\\n    if (obj) {\\n      this.value = obj;\\n    }\\n  }\\n\\n  loadMap(): void {\\n    this.loaderService.loadScript(`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=places`)\\n      .then(() => {\\n        this.initMap();\\n      })\\n      .catch(error => console.error('Google Maps loading failed: ', error));\\n  }\\n\\n  initMap() {\\n    if (isPlatformBrowser(this.platformId)) {\\n\\n      console.log(\\\"on after view init --> \\\", this.elemRef.nativeElement)\\n\\n      this.autocomplete = new google.maps.places.Autocomplete(\\n        this.elemRef.nativeElement\\n      );\\n\\n      const options: AutocompleteOptions = {\\n        // types: ['address'],\\n        // componentRestrictions: {country: this.country},\\n        placeIdOnly: this.placeIdOnly,\\n        strictBounds: this.strictBounds,\\n        // types: this.types,\\n        type: this.type\\n      };\\n\\n      // tslint:disable-next-line:no-unused-expression\\n      this.country ? options.componentRestrictions = {country: this.country} : null;\\n      // tslint:disable-next-line:no-unused-expression\\n      this.country ? options.types = this.types : null;\\n\\n      this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\\n      this.initGoogleMapsAutocomplete();\\n    }\\n  }\\n\\n}\\n\",\"import {Component, EventEmitter, forwardRef, Input, OnInit, Output} from '@angular/core';\\nimport {ControlValueAccessor, UntypedFormBuilder, UntypedFormGroup, NG_VALUE_ACCESSOR, Validators} from '@angular/forms';\\n\\nimport {parseGermanAddress} from '../../helpers/parser';\\nimport {GermanAddress} from '../../interfaces';\\nimport {Appearance} from '../mat-google-maps-autocomplete.component';\\nimport {InputAnimations} from '../../animations';\\nimport {debounceTime, distinctUntilChanged, takeUntil} from 'rxjs/operators';\\nimport {Subject} from 'rxjs';\\n\\n@Component({\\n  selector: 'mat-search-google-maps-autocomplete',\\n  templateUrl: './mat-search-google-maps-autocomplete.component.html',\\n  styleUrls: ['./mat-search-google-maps-autocomplete.component.scss'],\\n  animations: InputAnimations,\\n  providers: [\\n    {\\n      provide: NG_VALUE_ACCESSOR,\\n      useExisting: forwardRef(() => MatSearchGoogleMapsAutocompleteComponent),\\n      multi: true\\n    }\\n  ]\\n})\\nexport class MatSearchGoogleMapsAutocompleteComponent implements OnInit, ControlValueAccessor {\\n\\n  constructor(private formBuilder: UntypedFormBuilder) {\\n    // Set the private defaults\\n    this._unsubscribeAll = new Subject();\\n  }\\n\\n  @Input()\\n  searchBarAppearance: string | Appearance;\\n\\n  @Input()\\n  appearance: string | Appearance = Appearance.STANDARD;\\n\\n  @Input()\\n  searchAddressLabel = 'Search Address';\\n\\n  @Input()\\n  streetNameLabel = 'Street';\\n\\n  @Input()\\n  streetNumberLabel = 'Nr.';\\n\\n  @Input()\\n  postalCodeLabel = 'PLZ';\\n\\n  @Input()\\n  localityLabel = 'Locality';\\n\\n  @Input()\\n  vicinityLabel = 'Vicinity';\\n\\n  @Input()\\n  showVicinity: boolean;\\n\\n  @Input()\\n  country: string | string[];\\n\\n  @Input()\\n  placeIdOnly?: boolean;\\n\\n  @Input()\\n  strictBounds?: boolean;\\n\\n  @Input()\\n  types?: string[];\\n  // types: string[] = ['address'];\\n\\n  @Input()\\n  type?: string;\\n\\n  @Input()\\n  readonly: boolean;\\n\\n  @Input()\\n  disableSearch: boolean;\\n\\n  @Input() private _value: GermanAddress;\\n\\n  @Output()\\n  onGermanAddressMapped: EventEmitter<GermanAddress> = new EventEmitter<GermanAddress>();\\n\\n  germanAddress: GermanAddress;\\n  addressFormGroup: UntypedFormGroup;\\n\\n  firstInit = true;\\n\\n  // Private\\n  private _unsubscribeAll: Subject<any>;\\n\\n  propagateChange = (_: any) => {\\n  };\\n\\n\\n  get value(): GermanAddress {\\n    return this._value;\\n  }\\n\\n  @Input()\\n  set value(value: GermanAddress) {\\n    this._value = value;\\n    this.propagateChange(this.value);\\n  }\\n\\n  ngOnInit() {\\n    this.createAddressFormGroup();\\n    this.enableCustomInput();\\n  }\\n\\n  createAddressFormGroup(): void {\\n    this.addressFormGroup = this.formBuilder.group({\\n      streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\\n      streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\\n      postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\\n      vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\\n      locality: this.formBuilder.group({\\n        long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\\n      }),\\n    });\\n  }\\n\\n  enableCustomInput() {\\n    this.addressFormGroup\\n      .get('streetName')\\n      .valueChanges\\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\\n      .subscribe(streetName => {\\n        !this.value ? this.value = {streetName} : this.value.streetName = streetName;\\n        this.value.displayAddress = this.parseDisplayAddress();\\n        this.propagateChange(this.value);\\n      });\\n    this.addressFormGroup\\n      .get('streetNumber')\\n      .valueChanges\\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\\n      .subscribe(streetNumber => {\\n        !this.value ? this.value = {streetNumber} : this.value.streetNumber = streetNumber;\\n        this.value.displayAddress = this.parseDisplayAddress();\\n        this.propagateChange(this.value);\\n      });\\n    this.addressFormGroup\\n      .get('postalCode')\\n      .valueChanges\\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\\n      .subscribe(postalCode => {\\n        !this.value ? this.value = {postalCode} : this.value.postalCode = postalCode;\\n        this.value.displayAddress = this.parseDisplayAddress();\\n        this.propagateChange(this.value);\\n      });\\n    this.addressFormGroup\\n      .get('vicinity')\\n      .valueChanges\\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\\n      .subscribe(vicinity => {\\n        !this.value ? this.value = {vicinity} : this.value.vicinity = vicinity;\\n        this.value.displayAddress = this.parseDisplayAddress();\\n        this.propagateChange(this.value);\\n      });\\n    this.addressFormGroup\\n      .get('locality')\\n      .valueChanges\\n      .pipe(distinctUntilChanged(), debounceTime(400), takeUntil(this._unsubscribeAll))\\n      .subscribe(locality => {\\n        !this.value ? this.value = {locality} : this.value.locality = locality;\\n        this.value.displayAddress = this.parseDisplayAddress();\\n        this.propagateChange(this.value);\\n      });\\n  }\\n\\n  parseDisplayAddress() {\\n    return `${this.value?.streetName ? this.value?.streetName : ''} ${this.value?.streetNumber ? this.value?.streetNumber : ''}${this.value?.postalCode || this.value?.locality?.long ? ', ' : ''}${this.value?.postalCode ? this.value?.postalCode : ''} ${this.value?.locality?.long ? this.value?.locality?.long : ''}`\\n  }\\n\\n  syncAutoComplete($event: google.maps.places.PlaceResult) {\\n    if (this.germanAddress) {\\n      this.addressFormGroup.reset();\\n    }\\n    const germanAddress: GermanAddress = parseGermanAddress($event);\\n    this.germanAddress = germanAddress;\\n    if (germanAddress.vicinity) {\\n      this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity, {emitEvent: false, onlySelf: true});\\n    }\\n    if (germanAddress.streetName) {\\n      this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName, {emitEvent: false, onlySelf: true});\\n    }\\n    if (germanAddress.streetNumber) {\\n      this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber.toString(), {emitEvent: false, onlySelf: true});\\n    }\\n    if (germanAddress.postalCode) {\\n      this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode, {emitEvent: false, onlySelf: true});\\n    }\\n    if (germanAddress.locality && germanAddress.locality.long) {\\n      this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long, {emitEvent: false, onlySelf: true});\\n    }\\n\\n    this.value = germanAddress;\\n    this.onGermanAddressMapped.emit(germanAddress);\\n  }\\n\\n  writeValue(obj: any): void {\\n    let shouldRecreateFG = false;\\n    if (obj) {\\n      if (!this.value && this.firstInit) {\\n        shouldRecreateFG = true;\\n      }\\n      this.value = obj;\\n      if (shouldRecreateFG) {\\n        this.createAddressFormGroup();\\n        this.firstInit = false;\\n      }\\n    }\\n  }\\n\\n  registerOnChange(fn: any): void {\\n    this.propagateChange = fn;\\n  }\\n\\n  registerOnTouched(fn: any): void {\\n  }\\n\\n  setDisabledState(isDisabled: boolean): void {\\n  }\\n\\n}\\n\",\"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"searchBarAppearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          type=\\\"number\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\",\"import {CommonModule} from '@angular/common';\\nimport {InjectionToken, ModuleWithProviders, NgModule} from '@angular/core';\\nimport {FlexLayoutModule} from '@angular/flex-layout';\\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\\nimport {MatIconModule} from '@angular/material/icon';\\nimport {MatGoogleMapsAutocompleteDirective} from './directives/mat-google-maps-autocomplete.directive';\\nimport {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\\n// tslint:disable-next-line:max-line-length\\nimport {MatGoogleMapsAutocompleteComponent, MatSearchGoogleMapsAutocompleteComponent} from './component';\\nimport {MatInputModule} from '@angular/material/input';\\nimport {ApiKeyToken} from \\\"./tokens\\\";\\n\\n\\n\\n@NgModule({\\n  imports:\\n    [\\n      CommonModule,\\n      FormsModule,\\n      ReactiveFormsModule,\\n      FlexLayoutModule,\\n      MatInputModule,\\n      MatIconModule\\n    ],\\n  exports: [\\n    MatGoogleMapsAutocompleteComponent,\\n    MatGoogleMapsAutocompleteDirective,\\n    MatValidateAddressDirective,\\n    MatSearchGoogleMapsAutocompleteComponent\\n  ],\\n  declarations: [\\n    MatGoogleMapsAutocompleteComponent,\\n    MatGoogleMapsAutocompleteDirective,\\n    MatValidateAddressDirective,\\n    MatSearchGoogleMapsAutocompleteComponent\\n  ],\\n  providers: [\\n    // {\\n    //   provide: NG_VALUE_ACCESSOR,\\n    //   useExisting: forwardRef(() => MatGoogleMapsAutocompleteDirective),\\n    //   multi: true\\n    // }\\n  ]\\n})\\nexport class MatGoogleMapsAutocompleteModule {\\n\\n  constructor() {\\n  }\\n\\n  static forRoot(\\n    apiKey: string,\\n  ): ModuleWithProviders<MatGoogleMapsAutocompleteModule> {\\n\\n    return {\\n      ngModule: MatGoogleMapsAutocompleteModule,\\n      providers:\\n        [\\n          {\\n            provide: ApiKeyToken,\\n            useValue: apiKey\\n          },\\n        ]\\n    };\\n  }\\n}\\n\",\"/*\\n * Public API Surface of google-maps-autocomplete\\n */\\n\\nexport * from './lib/helpers/parser';\\nexport * from './lib/interfaces';\\nexport * from './lib/tokens';\\nexport * from './lib/component';\\nexport * from './lib/directives/mat-google-maps-autocomplete.directive';\\nexport * from './lib/directives/address-validator/mat-address-validator.directive';\\nexport * from './lib/mat-google-maps-autocomplete.module';\\n\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[\"i3\",\"i6.MatValidateAddressDirective\",\"i1.ScriptLoaderService\",\"i1\"],\"mappings\":\"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\"}","type":"asset"}]}